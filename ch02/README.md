# 第二章 套接字类型与协议设置

## 2.1 套接字协议及其数据传输特性

### 2.1.1 关于协议（Protocol）

如果相隔很远的人想展开对话，必须先决定对话方式。如果一方使用电话，那么另一方也只能使用电话，而不是书信。可以说，电话就是两个人对话的协议。协议是对话中使用的通信规则，把上述概念扩展到计算机领域可整理为“计算机对话必备通信规则”。

简而言之，协议就是为了完成数据交换而定好的约定。

### 2.1.2 创建套接字

创建套接字的函数

```c
#include <sys/socket.h>

int socket(int domain, int type, int protocol);
//上述函数执行执行成功时返回文件描述符，失败时返回-1

/***
  关于函数参数
	domain 套接字中使用的协议族（Prototol Family）信息。
	type 套接字数据传输类型信息
	protocol 计算机间通信使用的协议信息
***/
```



### 2.1.3 协议族（Prototol Family）

套接字通信中的协议有很多分类，每一种分类称为一个协议族。

头文件 <sys/socket.h>中声明的协议族

| 名称      | 协议族               |
| --------- | -------------------- |
| PF_INET   | IPv4互联网协议族     |
| PF_INET6  | IPv6互联网协议族     |
| PF_LOCAL  | 本地通信的UNIX协议族 |
| PF_PACKET | 底层套接字的协议族   |
| PF_IPX    | IPX Novell协议族     |

本书着重讲解PF_INET对应的IPv4互联网协议族。其它协议族并不常用或尚未普及，因此本书将重点放在PF_INET协议族上。另外，套接字中实际采用的最终协议信息是通过socket函数的第三个参数传递的。在指定的协议族范围内通过第一个参数决定第三个参数。



### 2.1.4 套接字类型（Type）

套接字类型指的是套接字的数据传输方式，通过socket函数的第二个参数传递，只有这样才能决定创建的套接字的数据传输方式。socket函数第一个参数PF_INET协议族中也存在多种数据传输方式。



**套接字类型1:  面向连接的套接字（SOCK_STREAM）**

> 如果向socket函数的第二个参数传递SOCK_STREAM，将创建面向连接的套接字。
>
> 面向连接的套接字主要有以下特点：
>
> - 传输过程中数据不会消失
> - 按序传输数据
> - 传输的数据不存在数据边界（Boundary）

==收发数据的套接字内部有缓冲（buffer）==，间言之就是字节数组。通过套接字传输的数据将保存到该数组。因此，收到数据并不意味着马上调用read函数。只要不超过数组容量，则有可能在数据填充满缓冲后==通过一次read函数调用读取全部，也可以分成多次read函数调用进行读取==。

如果read函数读取速度比接收数据的速度慢，则缓冲有可能被填满，即使这样也不会发生数据丢失，因为传输端套接字将停止传输。也就是说，==面向连接的套接字会根据接收端的状态传输数据，如果传输出错还会提供重传服务==。

作者自己的总结为：可靠的，按序传递的，基于字节的面向连接的数据传输方式的套接字。



**套接字类型2:  面向消息的套接字（SOCK_DGRAM）**

> 如果向socket函数的第二个参数传递SOCK_DGRAM，则将创建面向消息的套接字。面向消息的套接字可以比喻为高速移动的摩托车快递。
>
> 面向消息的套接字有以下特点：
>
> - 强调快速传输而非传输顺序
> - 传输的数据可能丢失也可能损毁
> - 传输的数据有数据边界
> - 限制每次传输的数据大小

如果用2辆摩托车分别发送2件包裹，这样无需保证顺序，只需以最快速度交给客户即可，但这样也存在损坏或丢失的风险。接收者也需要分两次接收。这种特性就是“传输的数据具有数据边界”



面向消息的套接字比面向连接的套接字具有更快的传输速度，但无法避免数据丢失或损坏。另外，每次传输的数据大小具有一定限制，并存在数据边界。存在数据边界意味着接收数据的次数应和传输次数相同。



总结如下：不可靠的，不按序传递的，以数据的高速传输为目的的套接字。



### 2.1.5 协议的最终选择

在同一协议族中若存在多个数据传输方式相同。

**在PE_INET只IPv4网络协议族下**

- SOCK_STREAM是面向连接的数据传输，满足这两个条件的协议只有IPPROTO_TCP。

  int tcp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_TCP);

- SOCK_DGRAM是面向消息的数据传输方式，满足这两个条件的协议只有IPPROTO_UDP

  int udp_socket = socket(PF_INET, SOCK_STREAM, IPPROTO_UDP);

## 2.2 面向连接的套接字：TCP套接字示例

把第一章文件

hello_server.c 替换为tcp_server.c  内容无变化

hello_client.c 替换为tcp_client.c  更改read函数调用方式

TCP套接字：传输的数据不存在边界

为了验证这一点，需要让write函数的调用次数不同于read函数的调用次数。因此，在客户端中分多次调用read函数以接收服务器端发送的全部数据。

代码详见：tcp_server.c         tcp_client.c(含注释)

**编译**:

```shell
gcc tcp_server.c -o tcp_server
gcc tcp_client.c -o tcp_client
```

**运行:**

```
./tcp_server 9190
./tcp_client 127.0.0.1 9190
```

**结果（标准输出）：**

```
Message from server: Hello World! 
Function read call count: 13 
```

由结果可知，服务器端发送的数据，客户端调用了13次read函数进行读取。

## 2.3 习题

（1）什么是协议？在收发数据中定义协议有何意义？

> 答：协议是对话中使用的通信规则，简而言之，协议就是为了完成数据交换而定好的约定。
>
> 在收发数据中定义协议可以让计算机之间进行通信。可以让计算机间进行通信，从而实现信息交换和资源共享。

（2）面向连接的TCP套接字传输特性有3点，请分别说明。

> 1. 传输过程中数据不会丢失
> 2. 按序传输数据
> 3. 传输的数据不存在数据边界（Boundary）

（3）下列哪些是面向消息的套接字特性？

a. 传输数据可能丢失

b. 没有数据边界(Boundary)

c. 以快速传递为目标

d. 不限制每次传递数据的大小

e. 与面向连接的套接字不同，不存在连接的概念

> 答：a,c,e
>
> b,d为面向连接的套接字特性

（4）下列数据适合用哪类套接字传输？并给出原因

a. 演唱会现场直播的多媒体数据

> 答：面向消息的套接字。需要快速传递数据，允许少量数据丢失或损坏

b. 某人压缩过的文本文件

> 答：面向连接的套接字。需要保证数据不会丢失。

c. 网上银行用户与银行之间的数据传递

> 答：面向连接的套接字。需要保证连接的可靠，数据传输的安全性。

（5）何种类型的套接字不存在数据边界？这类套接字接收数据时应该注意什么？

> 答：面向连接的套接字。
>
> 注意：对于接收端缓冲区，保证读取速度大于写入速度，否则缓冲区满后，传输端套接字将停止传输。

（6）tcp_server.c和tcp_client.c中需多次调用read函数读取服务器端调用1次write函数传递的字符串。更改程序，使服务器端多次调用（次数自拟）write函数传输数据，客户端调用1次read函数进行读取。为达到这一目的，客户端需延迟调用read函数。因为客户端要等待服务器端传输所有数据。Windows和Linux都通过下列代码延迟read或recv函数的调用。

```
for(int i=0;i<3000;i++)
   printf("Wait time %d \n",i);
```

让CPU执行多余任务以延迟代码运行的方式称为"Busy Waiting"。使用得当即可推迟函数调用。

示例代码：[tcp_server_wait.c](https://github.com/wangjunstf/TCP-IP-Network-Note/blob/main/ch02/src/tcp_server_wait.c)      [tcp_client_wait.c](https://github.com/wangjunstf/TCP-IP-Network-Note/blob/main/ch02/src/tcp_client_wait.c)



**编译：**

gcc tcp_server_wait.c -o tcp_server_wait

gcc tcp_client_wait.c -o tcp_client_wait



**运行：**

./tcp_server_wait 9190

./tcp_client_wait 127.0.0.1 9190



**客户端输出：**

Wait time 2993 

Wait time 2994 

Wait time 2995 

Wait time 2996 

Wait time 2997 

。。。。。

Wait time 2998 

Wait time 2999 

Message from server: Hello World! 